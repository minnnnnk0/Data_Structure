## Stack Queue 스택 큐

스택과 큐는 Javascript의 배열로 모든 것을 해결할 수 있다 ... !
| Stack(스택) | Queue(큐) |
| --- | --- |
| push와 pop을 사용 | push와 shift를 사용 |
| push : 뒤에서 추가 | push : 뒤에서 추가 |
| pop : 뒤에서 삭제 | shift : 앞에서 삭제 |
### push / pop / shift 시간복잡도는 O(n)이다

---
### Stack (LIFO 후입선출)   
-> length가 생길 수 있다   
스택에 정해진 용량이 있는데, 그것을 초과하면 **스택오버플로우**   
(50개의 용량에서 n개를 더 추가하려는 상황)

~~~
function a() {
    a();
}
a();
~~~
: Uncaught RangeError: Maxium call stack size exceeded

재귀함수를 사용하면 **스택오버플로우**가 발생한다.   
함수 안에 함수를 호출하면, 스택이 무한하게 쌓이다가 (각 브라우저마다 용량이 다르다) **Maxium call stack size exceeded** 에러 발생   

실제 프로그래밍에서 스택이 쓰이는 경우는   
기본적으로 함수 호출을 할 때, 함수가 끝나기 전에 다른 함수를 호출하는 경우 쓰임


### Queue (FIFO 선입선출) 
-> 대기열을 생각하면 쉬움 (선착순, 티켓팅, 수강신청)   
1, 2, 3, 4, 5, 6, 7, 8, 9, 10   
: 1번이 완료 후 제거되면 11번이 들어간다.   


*언제 사용되나?   
프로그래밍에선, 한번에 하나씩 밖에 처리하지 못하는데, 너무 많은 것들이 몰려오는 경우 **Queue**를 사용*


---

### Stack과 Queue의 공간복잡도
: 메모리공간을 얼마나 차지하고 있는가

ex
배열의 길이가 4라면, 메모리공간도 4를 차지   
그러므로 Stack과 Queue의 공간복잡도는 **O(n)**   

Node의 갯수와 메모리의 갯수가 일치하기 때문에   
연결리스트도 동일하게 공간복잡도는 O(n)

*Node 하나에 data, next, prev 3개의 데이터가 들어가는데 O(3n) 아닌가?*   
: O(n) === O(3n) 개수가 다르면 동일하다고 생각하면 됌   
지수가 달라야 유의미한 차이가 있다고 본다!
