## LinkedList 연결리스트

자료 구조를 시작할 때 **베열이 없다**라고 생각하고 시작하면 좋다.   
( 연결리스트, 스택, 큐 ... 이런 것들 사실 다 배열 하나로 되는 것 ).  
자료구조는 언어의 특색을 타지 않는다

### 배열
모든 언어에서의 배열은 사기적인 자료구조..   
C언어처럼 옛날 언어에서는 배열이 불편.  
JavaScript는 불편한 C의 배열에 기능이 매우 많이 추가되어 메모리 관리는 스스로 할 필요가 없도록 각종 편의 기능이 추가.  
그래서 자료구조를 배울 때, JavaScript의 배열이 매우 방해되는 요소가 됌.  
(그냥 편하게 배열로 해버리지.. 이러면 자료구조를 못 배우게 된다 ..ㅠㅠ).  
왜? 쉽게 쉽게 편하게 편하게가 되어버리니까 ..   

|      | A   | B   | C   | D     | E   | F     |
| ---- | --- | --- | --- | ----- | --- | ----- |
| 배열 | 1   | 2   | 3   | 4     | 5   | **6** |
| 객체 | a   | b   | c   | **7** |     |       |

이런 배열을 메모리라고 생각해본다면?   
(실제로는 이렇지 않지만 이차원배열이라고 생각하면 된다..)

1. A2에 7을 추가하려고 하는데 변수가 생긴다 (이미 객체가 존재)
2. 그럼 어쩔 수 없이 E2에 7을 추가.  
   -> 컴퓨터는 배열을 보고 데이터를 찾는게 아니라 메모리를 보고 데이터를 찾음
3. 메모리 값을 저장할 때 그 다음의 값이 어디있는지 힌트를 남긴다.  
**데이터(값, 다음 값의 위치)**
4. 이렇게 값들이 **채이닝** 되어있는데 이를 **연결리스트(LinkedList)** 라고 합니당!

조회, 삽입, 수정, 삭제의 시간 복잡도 4가지 경우 모두 **O(n)**

- 조회
  A1에서 5라는 값을 찾고 싶을 때.  
  B1부터 차례대로 연결되어 있는 값들을 찾아간다.   
  최악의 경우 => 찾는 값이 마지막에 있는 경우 O(n)
- 삽입(추가)
  A1에서 a라는 값을 넣고 싶을 때.  
  가장 마지막의 다음 값이 null인 경우 추가 O(n)

_연결리스트의 단점_.  
다음 값의 위치는 찾을 수 있지만, 이전 값을 찾지 못한다.   
**데이터 저장 방법은 자유이기 때문에, 이전 값 위치를 추가할 수 있음**.  
=> 자료구조는 응용이 가능하다 !!   
응용을 하다보면 최악의 경우 O(n)이 바뀔 수도 있다 (-> O(logn), O(1)로..).  
개선을 시도해보기
